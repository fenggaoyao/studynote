# 星期二

- 淘宝前端智能化
  算力 GPU CPU 并发计算 向量
  图计算

- 在子组件遇到 slot 标签，说明此处理需要此节点$slot内容，此处使用一个 withctx 的高阶函数，在创建父组件的，当前实例使用闭包的形式存储起来，此要渲染，即执行，同时将本节点的参数作为参数传入

- \$slot 是一个[string:vnode]的组合，它是*子组件*里的，instance.\$slot.default
- withCtx 返回一个高阶函数，接收的是\_renderSlot()，是实现组件参数回传
  slot ? slot(props) : fallback ? fallback() : []

blockstact 表示 block 树，currentblock 表示当前 block
openblock,往当前 blockStack 里 push 一个新 block,这个要先执行，执行 createBlock 时已经创建了 children 节点
父节点的 createBlock 函数执行前。子节点就已经通过 createVnode 创建了对应的 vnode

组件带 v-slot 指令，

<slot name="" :带变量，是 vnode 变量> rendSlot 返回：vonde,

```javascript
export function renderSlot(
  slots: Slots,
  name: string,
  props: Data = {},
  // this is not a user-facing function, so the fallback is always generated by
  // the compiler and guaranteed to be a function returning an array
  fallback?: () => VNodeArrayChildren
): VNode {
  let slot = slots[name]

  if (__DEV__ && slot && slot.length > 1) {
    warn(
      `SSR-optimized slot function detected in a non-SSR-optimized render ` +
        `function. You need to mark this component with $dynamic-slots in the ` +
        `parent template.`
    )
    slot = () => []
  }

  // a compiled slot disables block tracking by default to avoid manual
  // invocation interfering with template-based block tracking, but in
  // `renderSlot` we can be sure that it's template-based so we can force
  // enable it.
  isRenderingCompiledSlot++
  const rendered = (openBlock(),
  createBlock(
    Fragment,
    { key: props.key },
    slot ? slot(props) : fallback ? fallback() : [],
    (slots as RawSlots)._ === SlotFlags.STABLE
      ? PatchFlags.STABLE_FRAGMENT
      : PatchFlags.BAIL
  ))
  isRenderingCompiledSlot--
  return rendered
}


export function withCtx(
  fn: Slot,
  ctx: ComponentInternalInstance | null = currentRenderingInstance
) {
  if (!ctx) return fn
  const renderFnWithContext = (...args: any[]) => {
    // If a user calls a compiled slot inside a template expression (#1745), it
    // can mess up block tracking, so by default we need to push a null block to
    // avoid that. This isn't necessary if rendering a compiled `<slot>`.
    if (!isRenderingCompiledSlot) {
      openBlock(true /* null block that disables tracking */)
    }
    const owner = currentRenderingInstance
    setCurrentRenderingInstance(ctx)
    const res = fn(...args)
    setCurrentRenderingInstance(owner)
    if (!isRenderingCompiledSlot) {
      closeBlock()
    }
    return res
  }
  renderFnWithContext._c = true
  return renderFnWithContext
}

export const blockStack: (VNode[] | null)[] = []
let currentBlock: VNode[] | null = null
export function openBlock(disableTracking = false) {
  blockStack.push((currentBlock = disableTracking ? null : []))
}
export function closeBlock() {
  blockStack.pop()
  currentBlock = blockStack[blockStack.length - 1] || null
}
export function createBlock(
  type: VNodeTypes | ClassComponent,
  props?: Record<string, any> | null,
  children?: any,
  patchFlag?: number,
  dynamicProps?: string[]
): VNode {
  const vnode = createVNode(
    type,
    props,
    children,
    patchFlag,
    dynamicProps,
    true /* isBlock: prevent a block from tracking itself */
  )
  // save current block children on the block vnode
  vnode.dynamicChildren = currentBlock || EMPTY_ARR
  // close block
  closeBlock()
  // a block is always going to be patched, so track it as a child of its
  // parent block
  if (shouldTrack > 0 && currentBlock) {
    currentBlock.push(vnode)
  }
  return vnode
}


```
