
文档
编程架构
重构代码
设计系统架构
选型
优化性能
模块分解和微服务
保障系统安全与高可用
大数据应用
技术创新
沟通管理


创建对象模式
- 建造者模式

创建一个web容器，关联IOC容器，配置中心

创建一个IServer 可以是httpServer 启动依赖IHttpApplication<Context>，每一个请求就是在一个上下文里，处理请求，释放请求

处理请求，实现是一个个RequestDelegate，为对一组中间件的封装，它对请求的处理工作最终交给这些中间件来完成
所有中间件对请求的处理最终可以转换成一个RequestDelegate对象


application.ProcessRequestAsync(context)



在kestrel世界里，也有一个IConnectionBuilder.Use(Func<ConnectionDelegate, ConnectionDelegate> middleware)，Func<ConnectionDelegate, ConnectionDelegate>就是kestrel的中间件

```C#
kestrel.ListenAnyIP(port: 80, listen =>
{
    listen.Use(next => context =>
    {
        if(true)
        {
            // 中间件1的逻辑 
        }else
        {
            return next(context);
        }
    })
    .Use(next => context =>
    {
        if(true)
        {
            // 中间件2的逻辑
        }else
        {
            return next(context);
        }
    });
});

```

在kestrel中间件里，最重要的对象就是ConnectionDelegate，它等同于Func<ConnectionContext,Task>，我们可以理解为它就是一个Hanlder，传入连接上下文，剩下就是我们要干的工作了，而中间件是除了这个Handler之外，我们还能拿到一个叫next的Handler，我们可以选择是否调用它，如果不调用，流程终止。

ConnectionContext是kestrel的一个Tcp连接抽象，其核心属性是Transport，表示双工传输层的操作对象，另外提供Abort()方法用于服务端主动关闭连接。基于ConnectionContext，很容易实现一个自定义协议的tcp双工通讯服务器，相比从Socket写起，我们可能可以减少100倍代码量，而得到的是更高性能的服务。

kestrel的最后一个中间处理者是http中间件

- 单例模式，直接
- 原型模式
- 
